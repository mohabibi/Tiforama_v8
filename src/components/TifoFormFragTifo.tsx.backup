import React, { useState, useEffect } from 'react';
import { styled } from '@mui/material/styles';
import { 
  Box, 
  Button, 
  CircularProgress,
  Autocomplete,
  TextField,
  Fab,
  IconButton,
  InputAdornment
} from '@mui/material';
import RefreshIcon from '@mui/icons-material/Refresh';
import EditIcon from '@mui/icons-material/Edit';
import { useAppDispatch } from '../store';
import { setCurrentData } from '../store/tifoSlice';
import { TifoState } from '../types';
import { ApiService } from '../services/ApiService';
import { PlaceInput } from './PlaceInput';

const FormContainer = styled(Box)(({ theme }) => ({
  minHeight: '100vh',
  backgroundColor: '#000000',
  color: 'white',
  position: 'relative',
}));

const MainContent = styled(Box)(({ theme }) => ({
  padding: theme.spacing(3),
  maxWidth: 350,
  margin: '0 auto',
  paddingTop: theme.spacing(6),
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
}));

const StyledAutocomplete = styled(Autocomplete)(({ theme }) => ({
  marginBottom: theme.spacing(3),
  width: '100%',
  '& .MuiInputBase-root': {
    backgroundColor: '#2a2a2a',
    borderRadius: 12,
    border: 'none',
    color: 'white',
    fontSize: 16,
    padding: '4px 12px',
    height: 56,
  },
    fontSize: 16,
    height: 56,
  },
  '& .MuiInputLabel-root': {
    color: '#90EE90',
    fontSize: 14,
    fontWeight: 'normal',
  },
  '& .MuiInputLabel-root.Mui-focused': {
    color: '#90EE90',
  },
  '& .MuiOutlinedInput-notchedOutline': {
    border: 'none',
  },
  '& .MuiInputBase-input': {
    color: 'white',
    fontSize: 16,
  },
}));

const PlaceTextField = styled(TextField)<{ $hasPlaces?: boolean; $totalPlaces?: number }>(({ theme, $hasPlaces, $totalPlaces }) => ({
  marginBottom: theme.spacing(3),
  width: '100%',
  '& .MuiInputBase-root': {
    backgroundColor: '#2a2a2a',
    borderRadius: 12,
    border: 'none',
    color: 'white',
    fontSize: 16,
    height: 56,
    position: 'relative',
  },
  '& .MuiInputLabel-root': {
    color: '#90EE90',
    fontSize: 14,
    fontWeight: 'normal',
  },
  '& .MuiInputLabel-root.Mui-focused': {
    color: '#90EE90',
  },
  '& .MuiOutlinedInput-notchedOutline': {
    border: 'none',
  },
  '& .MuiInputBase-input': {
    fontSize: 16,
    fontWeight: 'bold',
  },
  // Style sp√©cial pour le format "XXX/YYY"
  ...$hasPlaces && {
    '& .MuiInputBase-input': {
      color: 'white',
      fontSize: 16,
      fontWeight: 'bold',
      '&::before': {
        color: '#FF0000', // Rouge pour la partie saisie
      }
    }
  }
}));

const ValidateButton = styled(Button)<{ $canValidate?: boolean }>(({ $canValidate }) => ({
  backgroundColor: $canValidate ? '#FFFFFF' : '#555555',
  color: $canValidate ? '#000000' : 'white',
  fontWeight: 'bold',
  borderRadius: 25,
  padding: '14px 50px',
  marginTop: '24px',
  marginBottom: '40px',
  textTransform: 'none',
  fontSize: 16,
  minWidth: 140,
  height: 48,
  transition: 'all 0.3s ease',
  opacity: $canValidate ? 1 : 0.6,
  '&:hover': {
    backgroundColor: $canValidate ? '#F0F0F0' : '#666666',
  },
  '&:disabled': {
    backgroundColor: '#333333',
    color: '#666666',
  },
}));

const MemoryCirclesContainer = styled(Box)({
  display: 'grid',
  gridTemplateColumns: 'repeat(5, 1fr)',
  gridTemplateRows: 'repeat(2, 1fr)',
  gap: '20px',
  justifyItems: 'center',
  marginTop: '40px',
  marginBottom: '120px',
  padding: '0',
  width: '100%',
  maxWidth: 320,
  margin: '40px auto 120px auto', // Centrage horizontal automatique
  transform: 'translateX(-25px)', // D√©calage de 25px vers la gauche
});

const MemoryCircle = styled(Box)<{ $isActive: boolean }>(({ $isActive }) => ({
  width: '54px',
  height: '54px',
  borderRadius: '50%',
  backgroundColor: $isActive ? '#444444' : 'rgba(42, 42, 42, 0.6)',
  border: '1px solid rgba(85, 85, 85, 0.8)',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  fontSize: '20px',
  fontWeight: 'bold',
  color: $isActive ? 'white' : 'rgba(255, 255, 255, 0.4)',
  cursor: $isActive ? 'pointer' : 'default',
  transition: 'all 0.3s ease',
  opacity: $isActive ? 1 : 0.6,
  '&:hover': $isActive ? {
    backgroundColor: '#555555',
    transform: 'scale(1.1)',
    borderColor: 'rgba(85, 85, 85, 1)',
    opacity: 1,
  } : {},
}));

const RefreshButton = styled(Fab)({
  position: 'fixed',
  bottom: '24px',
  left: '24px', // Chang√© de right √† left comme demand√©
  backgroundColor: '#ff1744',
  color: 'white',
  width: '56px',
  height: '56px',
  '&:hover': {
    backgroundColor: '#d50000',
    transform: 'scale(1.1)',
  },
  transition: 'all 0.3s ease',
});

const PlaceDisplayContainer = styled(Box)({
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  marginBottom: '16px',
  fontSize: '18px',
  fontWeight: 'bold',
  minHeight: '24px',
});

const PlaceDisplayText = styled('span')<{ $isUserInput?: boolean }>(({ $isUserInput }) => ({
  color: $isUserInput ? '#FF0000' : 'rgba(255, 255, 255, 0.4)',
  fontSize: '18px',
  fontWeight: 'bold',
}));

// Interfaces correspondant exactement √† votre API FragTifo
interface Group {
  id: number;
  name: string;
}

interface Tifo {
  id: number;
  name: string;
  group_id: number;
}

interface TifoData {
  groupe: string;
  tifo: string;
  place: string;
  colors: number[];
  icons: string[];
  durations: number[];
  palette: string[];
  mp3: string | null;
  nombre_places: number;
}

interface SavedData {
  group_name: string;
  tifo_name: string;
  place_number: number;
  data: TifoData;
  timestamp: number;
}

export const TifoFormFragTifo: React.FC = () => {
  const dispatch = useAppDispatch();
  const apiService = ApiService.getInstance();

  // √âtats principaux du formulaire (comme dans Flutter)
  const [selectedGroup, setSelectedGroup] = useState<Group | null>(null);
  const [selectedTifo, setSelectedTifo] = useState<Tifo | null>(null);
  const [placeNumber, setPlaceNumber] = useState<string>('');
  const [placeHint, setPlaceHint] = useState<string>('0');
  const [totalPlaces, setTotalPlaces] = useState<number>(0);
  const [customGroupName, setCustomGroupName] = useState<string>('');
  const [isAddingCustomGroup, setIsAddingCustomGroup] = useState<boolean>(false);
  const [isUsingTestData, setIsUsingTestData] = useState<boolean>(false);

  // √âtats des donn√©es
  const [groups, setGroups] = useState<Group[]>([]);
  const [tifos, setTifos] = useState<Tifo[]>([]);
  const [savedData, setSavedData] = useState<SavedData[]>([]);
  
  // √âtats de chargement
  const [isLoading, setIsLoading] = useState(false);
  const [isLoadingGroups, setIsLoadingGroups] = useState(false);
  const [isLoadingTifos, setIsLoadingTifos] = useState(false);

  // Debug de totalPlaces
  useEffect(() => {
    console.log(`üî¢ TotalPlaces mis √† jour:`, totalPlaces);
  }, [totalPlaces]);

  // Charger les donn√©es initiales (comme dans Flutter)
  useEffect(() => {
    const initializeApp = async () => {
      await fetchGroups();
      await loadSavedData();
    };
    initializeApp();
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  // R√©cup√©rer les groupes depuis l'API FragTifo
  const fetchGroups = async () => {
    setIsLoadingGroups(true);
    try {
      console.log('üì° R√©cup√©ration des groupes depuis FragTifo API...');
      const groupsData = await apiService.getGroups();
      setGroups(groupsData);
      console.log(`‚úÖ ${groupsData.length} groupes r√©cup√©r√©s`);
    } catch (error) {
      console.error('‚ùå Erreur lors de la r√©cup√©ration des groupes:', error);
      // Continuer avec des donn√©es de d√©monstration si l'API n'est pas disponible
    } finally {
      setIsLoadingGroups(false);
    }
  };

  // R√©cup√©rer les tifos d'un groupe
  const fetchTifos = async (groupId: number) => {
    setIsLoadingTifos(true);
    setTifos([]);
    setSelectedTifo(null);
    setPlaceNumber('');
    setPlaceHint('0');
    
    try {
      console.log(`üì° R√©cup√©ration des tifos pour le groupe ${groupId}...`);
      const tifosData = await apiService.getTifosByGroup(groupId);
      setTifos(tifosData);
      console.log(`‚úÖ ${tifosData.length} tifos r√©cup√©r√©s`);
    } catch (error) {
      console.error('‚ùå Erreur lors de la r√©cup√©ration des tifos:', error);
      // Continuer avec des donn√©es de d√©monstration si l'API n'est pas disponible
    } finally {
      setIsLoadingTifos(false);
    }
  };

  // R√©cup√©rer la derni√®re place utilis√©e pour un tifo
  const fetchLastPlace = async (tifoId: number) => {
    try {
      console.log(`üì° R√©cup√©ration de la derni√®re place pour le tifo ${tifoId}...`);
      const lastPlace = await apiService.getLastPlace(tifoId);
      setPlaceHint(lastPlace.toString());
      console.log(`‚úÖ Derni√®re place r√©cup√©r√©e: ${lastPlace}`);
    } catch (error) {
      console.error('‚ùå Erreur lors de la r√©cup√©ration de la derni√®re place:', error);
      setPlaceHint('0');
    }
  };

  // R√©cup√©rer les informations d'un tifo (nombre de places)
  const fetchTifoInfo = async (groupName: string, tifoName: string) => {
    try {
      console.log(`üì° R√©cup√©ration des informations du tifo ${tifoName}...`);
      console.log(`üîç Param√®tres: groupe="${groupName}", tifo="${tifoName}"`);
      
      const tifoInfo = await apiService.getTifoInfo(groupName, tifoName);
      console.log(`üìä R√©ponse getTifoInfo:`, tifoInfo);
      
      if (tifoInfo && tifoInfo.nombre_places > 0) {
        console.log(`‚úÖ Nombre de places r√©cup√©r√©: ${tifoInfo.nombre_places}`);
        setTotalPlaces(tifoInfo.nombre_places);
        setIsUsingTestData(false);
      } else {
        console.warn('‚ö†Ô∏è API non accessible ou nombre de places = 0, utilisation de donn√©es de test');
        // Donn√©es de test pour permettre de tester l'interface m√™me sans API
        const testPlaces = getTestPlacesForTifo(tifoName);
        setTotalPlaces(testPlaces);
        setIsUsingTestData(true);
        console.log(`üß™ Utilisation de ${testPlaces} places pour les tests`);
      }
    } catch (error) {
      console.error('‚ùå Erreur lors de la r√©cup√©ration des informations du tifo:', error);
      // Fallback avec donn√©es de test
      const testPlaces = getTestPlacesForTifo(tifoName);
      setTotalPlaces(testPlaces);
      setIsUsingTestData(true);
      console.log(`üß™ Fallback: utilisation de ${testPlaces} places pour les tests`);
    }
  };

  // Fonction pour obtenir des donn√©es de test bas√©es sur le nom du tifo
  const getTestPlacesForTifo = (tifoName: string): number => {
    const testData: { [key: string]: number } = {
      'Tifo Victoire': 150,
      'Chor√©graphie Flammes': 200,
      'Mosa√Øque G√©ante': 300,
      'Animation Lumi√®re': 180,
      'Banderoles Unies': 100,
      // Valeurs par d√©faut selon la longueur du nom
    };
    
    return testData[tifoName] || Math.floor(Math.random() * 200) + 50; // 50-250 places al√©atoires
  };

  // Charger les donn√©es sauvegard√©es depuis localStorage
  const loadSavedData = async () => {
    try {
      const savedDataString = localStorage.getItem('tiforama_saved_data');
      if (savedDataString) {
        const parsed = JSON.parse(savedDataString);
        setSavedData(parsed);
        console.log(`üì± ${parsed.length} donn√©es sauvegard√©es charg√©es`);
      }
    } catch (error) {
      console.error('‚ùå Erreur lors du chargement des donn√©es sauvegard√©es:', error);
    }
  };

  // Sauvegarder les donn√©es dans localStorage
  const saveDataToMemory = (data: TifoData) => {
    try {
      const newSavedData: SavedData = {
        group_name: selectedGroup?.name || '',
        tifo_name: selectedTifo?.name || '',
        place_number: parseInt(placeNumber),
        data: data,
        timestamp: Date.now()
      };

      const updatedSavedData = [newSavedData, ...savedData.slice(0, 9)]; // Garder seulement 10 √©l√©ments
      setSavedData(updatedSavedData);
      localStorage.setItem('tiforama_saved_data', JSON.stringify(updatedSavedData));
      console.log('üíæ Donn√©es sauvegard√©es en m√©moire');
    } catch (error) {
      console.error('‚ùå Erreur lors de la sauvegarde:', error);
    }
  };

  // Gestion des changements de champs (comme dans Flutter)
  useEffect(() => {
    const handleFieldChange = () => {
      if (selectedGroup || selectedTifo || placeNumber) {
        // Logique pour g√©rer les changements de champs
      }
    };
    handleFieldChange();
  }, [selectedGroup, selectedTifo, placeNumber]);

  // Gestion de la s√©lection du groupe
  const handleGroupChange = (event: any, newValue: Group | null) => {
    setSelectedGroup(newValue);
    setIsAddingCustomGroup(false);
    setCustomGroupName('');
    if (newValue) {
      fetchTifos(newValue.id);
    } else {
      setTifos([]);
      setSelectedTifo(null);
      setPlaceNumber('');
      setPlaceHint('0');
      setTotalPlaces(0);
    }
  };

  // Gestion de l'ajout d'un groupe personnalis√©
  const handleAddCustomGroup = () => {
    setIsAddingCustomGroup(true);
    setSelectedGroup(null);
    setTifos([]);
    setSelectedTifo(null);
    setPlaceNumber('');
    setPlaceHint('0');
    setTotalPlaces(0);
  };

  const handleCustomGroupNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setCustomGroupName(event.target.value);
  };

  const handleCustomGroupSubmit = () => {
    if (customGroupName.trim()) {
      // Cr√©er un groupe temporaire avec le nom personnalis√©
      const customGroup: Group = {
        id: -1, // ID temporaire
        name: customGroupName.trim()
      };
      setSelectedGroup(customGroup);
      setIsAddingCustomGroup(false);
      setCustomGroupName('');
      // Les tifos resteront vides pour un groupe personnalis√©
      setTifos([]);
    }
  };

  // Gestion de la s√©lection du tifo
  const handleTifoChange = (event: any, newValue: Tifo | null) => {
    console.log(`üéØ S√©lection tifo:`, newValue);
    console.log(`üéØ Groupe actuel:`, selectedGroup);
    
    setSelectedTifo(newValue);
    setPlaceNumber('');
    setTotalPlaces(0);
    
    if (newValue && selectedGroup) {
      console.log(`üîÑ R√©cup√©ration des donn√©es pour tifo "${newValue.name}" du groupe "${selectedGroup.name}"`);
      
      // R√©cup√©rer la derni√®re place utilis√©e
      fetchLastPlace(newValue.id);
      
      // R√©cup√©rer les informations du tifo (nombre de places)
      fetchTifoInfo(selectedGroup.name, newValue.name);
    } else {
      console.log(`‚ö†Ô∏è Pas de r√©cup√©ration - tifo ou groupe manquant`);
      setPlaceHint('0');
    }
  };

  // Gestion de la saisie du num√©ro de place
  const handlePlaceNumberChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    let value = event.target.value;
    
    // Si totalPlaces > 0, on g√®re le format "XXX/YYY"
    if (totalPlaces > 0) {
      // Extraire seulement la partie num√©rique avant le "/"
      const match = value.match(/^(\d*)/);
      value = match ? match[1] : '';
    }
    
    const numericValue = parseInt(value);
    
    // V√©rifier que le num√©ro de place est strictement inf√©rieur au total (0 √† totalPlaces-1)
    if (totalPlaces > 0 && numericValue >= totalPlaces) {
      console.warn(`‚ö†Ô∏è Le num√©ro de place (${numericValue}) doit √™tre strictement inf√©rieur au nombre total de places (${totalPlaces}). Places disponibles: 0 √† ${totalPlaces - 1}`);
      // Optionnel: emp√™cher la saisie ou limiter √† totalPlaces - 1
      return;
    }
    
    // V√©rifier que le num√©ro de place n'est pas n√©gatif
    if (numericValue < 0) {
      console.warn(`‚ö†Ô∏è Le num√©ro de place ne peut pas √™tre n√©gatif`);
      return;
    }
    
    setPlaceNumber(value);
  };

  // Calculer si on peut valider (d√®s le premier chiffre saisi et place valide)
  const canValidate = Boolean(
    selectedGroup && 
    selectedTifo && 
    placeNumber && 
    placeNumber.length > 0 &&
    parseInt(placeNumber) >= 0 &&
    (totalPlaces === 0 || parseInt(placeNumber) < totalPlaces) // V√©rification stricte: 0 √† totalPlaces-1
  );

  // Validation et r√©cup√©ration des donn√©es (comme dans Flutter)
  const handleValidation = async () => {
    if (!selectedGroup || !selectedTifo || placeNumber === '') {
      console.warn('‚ö†Ô∏è Veuillez remplir tous les champs');
      return;
    }

    const placeNum = parseInt(placeNumber);
    
    // V√©rification que la place est valide (0 √† totalPlaces-1)
    if (totalPlaces > 0 && (placeNum < 0 || placeNum >= totalPlaces)) {
      console.error(`‚ùå Num√©ro de place invalide: ${placeNum} doit √™tre entre 0 et ${totalPlaces - 1}`);
      return;
    }

    setIsLoading(true);

    try {
      // 1. Valider les donn√©es
      console.log('üîç Validation des donn√©es...');
      const validation = await apiService.validateData(
        selectedGroup.name,
        selectedTifo.name,
        placeNum
      );

      if (!validation.success) {
        console.error('‚ùå Donn√©es invalides:', validation.error);
        setIsLoading(false);
        return;
      }

      // 2. R√©cup√©rer les donn√©es compl√®tes du tifo
      console.log('üì° R√©cup√©ration des donn√©es du tifo...');
      const tifoData = await apiService.getTifoDataByParams(
        selectedGroup.name,
        selectedTifo.name,
        placeNum
      );

      // 3. Sauvegarder en m√©moire
      saveDataToMemory(tifoData);

      // 4. Convertir pour Redux (format TifoState)
      const tifoState: TifoState = {
        colors: tifoData.colors,
        durations: tifoData.durations,
        palette: tifoData.palette,
        icons: tifoData.icons,
        mp3_local: tifoData.mp3 || ''
      };

      // 5. Mettre √† jour Redux
      dispatch(setCurrentData(tifoState));

      console.log('‚úÖ Donn√©es charg√©es et pr√™tes pour l\'animation');

    } catch (error) {
      console.error('‚ùå Erreur lors de la validation/r√©cup√©ration:', error);
    } finally {
      setIsLoading(false);
    }
  };

  // Charger une donn√©e sauvegard√©e
  const loadSavedDataItem = async (index: number) => {
    const item = savedData[index];
    if (!item) return;

    setIsLoading(true);
    try {
      // Reconvertir pour Redux
      const tifoState: TifoState = {
        colors: item.data.colors,
        durations: item.data.durations,
        palette: item.data.palette,
        icons: item.data.icons,
        mp3_local: item.data.mp3 || ''
      };

      dispatch(setCurrentData(tifoState));

      console.log(`‚úÖ Donn√©es charg√©es depuis la m√©moire (slot ${index + 1})`);
    } catch (error) {
      console.error('‚ùå Erreur lors du chargement depuis la m√©moire:', error);
    } finally {
      setIsLoading(false);
    }
  };

  // Rafra√Æchir les donn√©es et resynchroniser l'horloge UTC
  const handleRefresh = async () => {
    console.log('üîÑ Rafra√Æchissement complet de l\'application...');
    console.log('üì± R√©initialisation de la page d√©tect√©e - mise √† jour obligatoire de l\'offset');
    
    // 1. R√©initialiser le formulaire
    fetchGroups();
    setSelectedGroup(null);
    setSelectedTifo(null);
    setPlaceNumber('');
    setPlaceHint('0');
    setTotalPlaces(0);
    setIsAddingCustomGroup(false);
    setCustomGroupName('');
    
    console.log('‚úÖ Application rafra√Æchie');
  };

  return (
    <FormContainer>
      <MainContent>
        {/* Champ Groupe avec bouton d'ajout personnalis√© */}
        {!isAddingCustomGroup ? (
          <StyledAutocomplete
            options={groups}
            getOptionLabel={(option) => option.name}
            value={selectedGroup}
            onChange={handleGroupChange}
            loading={isLoadingGroups}
            renderInput={(params) => (
              <TextField
                {...params}
                label="S√©lectionnez votre groupe"
                variant="outlined"
                fullWidth
                InputProps={{
                  ...params.InputProps,
                  endAdornment: (
                    <>
                      {isLoadingGroups ? <CircularProgress color="inherit" size={20} /> : null}
                      {params.InputProps.endAdornment}
                      <InputAdornment position="end">
                        <IconButton
                          onClick={handleAddCustomGroup}
                          size="small"
                          sx={{ color: 'white', marginLeft: 1 }}
                          title="Ajouter un groupe personnalis√©"
                        >
                          <EditIcon fontSize="small" />
                        </IconButton>
                      </InputAdornment>
                    </>
                  ),
                }}
              />
            )}
          />
        ) : (
          <StyledTextField
            label="Nom du groupe personnalis√©"
            variant="outlined"
            fullWidth
            value={customGroupName}
            onChange={handleCustomGroupNameChange}
            onKeyPress={(e) => e.key === 'Enter' && handleCustomGroupSubmit()}
            onBlur={handleCustomGroupSubmit}
            autoFocus
          />
        )}

        {/* Champ Tifo */}
        <StyledAutocomplete
          options={tifos}
          getOptionLabel={(option) => option.name}
          value={selectedTifo}
          onChange={handleTifoChange}
          loading={isLoadingTifos}
          disabled={!selectedGroup}
          renderInput={(params) => (
            <TextField
              {...params}
              label="S√©lectionnez votre tifo"
              variant="outlined"
              fullWidth
              InputProps={{
                ...params.InputProps,
                endAdornment: (
                  <>
                    {isLoadingTifos ? <CircularProgress color="inherit" size={20} /> : null}
                    {params.InputProps.endAdornment}
                  </>
                ),
              }}
            />
          )}
        />

        {/* Affichage du nombre de places total */}
        {totalPlaces > 0 && !isUsingTestData && (
          <PlaceDisplayContainer>
            <PlaceDisplayText>
              Nombre de places : {totalPlaces}
            </PlaceDisplayText>
          </PlaceDisplayContainer>
        )}

        {/* Champ Place avec affichage dynamique int√©gr√© */}
        <PlaceInput
          value={placeNumber}
          onChange={(value) => {
            const numericValue = parseInt(value);
            
            // V√©rifier que le num√©ro de place est strictement inf√©rieur au total (0 √† totalPlaces-1)
            if (totalPlaces > 0 && numericValue >= totalPlaces) {
              console.warn(`‚ö†Ô∏è Le num√©ro de place (${numericValue}) doit √™tre strictement inf√©rieur au nombre total de places (${totalPlaces}). Places disponibles: 0 √† ${totalPlaces - 1}`);
              return;
            }
            
            // V√©rifier que le num√©ro de place n'est pas n√©gatif
            if (numericValue < 0) {
              console.warn(`‚ö†Ô∏è Le num√©ro de place ne peut pas √™tre n√©gatif`);
              return;
            }
            
            setPlaceNumber(value);
          }}
          totalPlaces={totalPlaces}
          disabled={!selectedTifo}
          error={Boolean(totalPlaces > 0 && placeNumber && parseInt(placeNumber) >= totalPlaces)}
          placeholder={placeHint}
        />

        {/* Messages d'erreur pour les places */}
        {totalPlaces > 0 && placeNumber && parseInt(placeNumber) >= totalPlaces && (
          <Box sx={{ color: '#f44336', fontSize: '12px', marginTop: '-16px', marginBottom: '16px' }}>
            Le num√©ro doit √™tre entre 0 et {totalPlaces - 1}
          </Box>
        )}
        {totalPlaces > 0 && !placeNumber && (
          <Box sx={{ color: 'rgba(255,255,255,0.6)', fontSize: '12px', marginTop: '-16px', marginBottom: '16px' }}>
            Saisissez un num√©ro entre 0 et {totalPlaces - 1}
          </Box>
        )}

        {/* Affichage du format "125/2500" - maintenant int√©gr√© dans le champ */}
        {/* Supprim√© car maintenant affich√© directement dans PlaceTextField */}

        {/* Bouton Valider */}
        <ValidateButton
          onClick={handleValidation}
          disabled={!canValidate || isLoading}
          $canValidate={canValidate}
        >
          {isLoading ? (
            <CircularProgress size={24} color="inherit" />
          ) : (
            'Valider'
          )}
        </ValidateButton>

        {/* Cercles de m√©moire (10 cercles semi-transparents) */}
        <MemoryCirclesContainer>
          {Array.from({ length: 10 }, (_, index) => {
            const isActive = index < savedData.length;
            return (
              <MemoryCircle
                key={index}
                $isActive={isActive}
                onClick={() => isActive && loadSavedDataItem(index)}
              >
                {index}
              </MemoryCircle>
            );
          })}
        </MemoryCirclesContainer>
      </MainContent>

      {/* Bouton Refresh rouge en bas √† gauche */}
      <RefreshButton onClick={handleRefresh} title="R√©initialiser la page et l'horloge UTC">
        <RefreshIcon />
      </RefreshButton>

      {/* Overlay de chargement */}
      {isLoading && (
        <Box
          position="fixed"
          top={0}
          left={0}
          right={0}
          bottom={0}
          display="flex"
          alignItems="center"
          justifyContent="center"
          bgcolor="rgba(0, 0, 0, 0.8)"
          zIndex={9999}
        >
          <CircularProgress size={60} color="primary" />
        </Box>
      )}
    </FormContainer>
  );
};
